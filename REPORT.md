Тестовое покрытие кода в JACOCO 
-

Покрытие кода, с точки зрения качества может быть достигнуто, но с практической точки зрения полное покрытие нереально, и тестирование покрытия как цели качества не имеет никакого смысла. Из существующих инструментов обнаружения покрытия, даже если покрытие достигает 100%, все ветви кода не могут быть покрыты.

**Смысл покрытия кода**

1. Проанализируйте код, который не охватывается, чтобы сделать вывод о том, является ли дизайн теста достаточным на ранней стадии, и является ли код, который не охватывается, слепым пятном проекта теста. Почему бы не рассмотреть его? Требования / дизайн недостаточно ясны, дизайн теста неправильно понят, стратегический отказ, вызванный применением инженерного метода и т. Д., и затем выполняется проект дополнительного тестового примера.
2. Обнаружение устаревшего кода в программе может обратить вспять путаницу в мышлении при разработке кода, напомнив дизайнерам / разработчикам прояснить логические взаимосвязи кода и улучшить качество кода.

3. Высокое покрытие кода не указывает на высокое качество кода, но, с другой стороны, покрытие кода низкое, а качество кода не такое высокое, и его можно использовать в качестве одного из важных инструментов для тестирования самопроверки.

Jacoco включает в себя счетчики покрытия в различных масштабах, включая уровень команд (покрытие C0), ветви (покрытие C1), цикломатическую сложность, линии, методы (неабстрактные методы), класс (классы).

- **Инструкции**: Самая маленькая единица, которую вычисляет Jacoco, является инструкцией байт-кода. Охват инструкций указывает, какие инструкции были выполнены, а какие не были выполнены во всех инструкциях. Этот индекс полностью независим от исходного формата и действителен при любых обстоятельствах и не требует отладочной информации для файлов классов.

- **Ветви**: Jacoco рассчитывает покрытие ветви для всех инструкций if и switch. Этот индикатор будет подсчитывать количество всех ветвей и одновременно тратить, какие ветви выполняются, а какие не выполняются. Этот показатель также действителен в любом случае. Обработка исключений не рассматривается в рамках ветви.
- **Цикломатическая сложность**: Jacoco вычисляет цикломатическую сложность для каждого неабстрактного метода, а также вычисляет сложность каждого класса, пакета и группы. Согласно определению МакКейба от 1996 года, цикломатическая сложность может пониматься как охватывающая количество тестовых случаев, которые с наименьшей вероятностью будут использоваться. Этот параметр также действителен при любых обстоятельствах.

- **Линии**: этот индекс рассчитывается с помощью информации отладки.
- **Методы**: у каждого неабстрактного метода есть хотя бы одна инструкция. Метод считается выполненным, если он выполнил хотя бы одну инструкцию. Поскольку Jacoco работает непосредственно с байт-кодом, некоторые методы (например, некоторые конструкторы и методы, автоматически генерируемые компилятором) не включены в исходный код.
- **Классы**: пока выполняется один метод в каждом классе, этот класс считается выполненным. Как и в случае с 5, некоторые методы, которые не объявлены в исходном коде, выполняются, и класс считается выполненным.
 
Отчеты JaCoCo помогают нам визуально анализировать покрытие кода с помощью ромбов с цветами для ветвей и цветов фона для линий:
 - *Красный бриллиант*  означает, что во время фазы тестирования ветви не были задействованы.
 - *Желтый бриллиант*  показывает, что код частично закрыт - некоторые ветви не были отработаны.
 - *Зеленый бриллиант* означает, что во время теста были задействованы все ветви.